# 复杂度分析

数据结构与算法帮我们解决的是 “如何让计算机用更快的时间和更小的空间来解决问题”，因此我们需要从两个纬度来评估数据结构与算法的性能：**时间纬度**、**空间纬度**

### 如何进行复杂度分析

#### 大O时间复杂度表示法

大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**所以也叫**渐近时间复杂度**(asymptotic time complexity),简称才是**时间复杂度**

##### 推导过程(伪)

```js
const cal = (n) => {
  const sum = 0;
  for (let i = 0; i <=n ; i++) {
    sum += i;
  }
  return sum;
}
```

我们如何来计算这一段代码的执行时间呢？首先我们要做一个假设就是cpu执行每行代码的开销都是相同的，给定为`unit_time`, 那么在这个基础上我们代码执行的总时间如下：

```js
const cal = (n) => {
  const sum = 0;                  // 1 * unit_time
  for (let i = 0; i <=n ; i++) {  // n * unit_time
    sum += i;                     // n * unit_time
  }
  return sum;
```

所以我们这段代码运行的总时间就是`T(n) = (2n + 1) * unit_time`, 尽管我们不知道`unit_time`的具体值，但是我们可以获得一个非常简单的规律就是**所有代码的执行时间 T(n) 与每行代码执行次数 n 成正比**，我们将这个规律总结为一个公式就是:

```sh
T(n) = O(f(n))
```

* T(n)：代码执行的时间
* n：数据规模的大小
* f(n)：代码执行次数的总和
* O: 表示代码执行的时间 T(n) 与 代码执行的总次数 f(n) 成正比

#### 时间复杂度分析的技巧与方法

1. 只关注循环次数最多的一次代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法制：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

#### 几种常见时间复杂度的分析

![常见的复杂度图片](https://tva1.sinaimg.cn/large/006tNbRwly1gbcaj98lf6j30vq0fwjti.jpg)

* 多项式量级
  * 除了非多项式量级
* 非多项式量级 **NP问题**
  * 指数阶
  * 阶乘阶

##### 1. O(1)

代码执行的时间与n无关的，都是O(1)。

##### 2. O(logn)、O(nlogn)

```js
let i = 1;
while (i <= n) {
  i = i * 2;
}
```

其实我们只要计算出这段代码循环的次数就可以了，其实变量`i`是一个等比的数列，那其实我们只要计算

```sh
2 ^ x = n
```

中的`x`的值就可以，所以 `x = log2(n)`, 所以这个代码的时间复杂度就是 `O(log2n)`

我们知道对数之间是可以相互转换的，`O(log2n) = O(C * logn)`, 所以我们忽略系数，统一表示为`O(logn)`

##### 3. O(m+m) O(m*n)

这个复杂度是由两个数据的规模来决定的

```js
const cal = (n, m) => {
  let sumN = 0;
  let sunM = 0;
  for (let i = 0; i <=n ; i++) {
    sunN += i;
  }
  for (let i = 0; i <=m ; i++) {
    sumM += i;
  }
  return sumM + sumN;
}
```

#### 空间复杂度分析

空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

常用的空间复杂度就是 O(1), O(n), O(n^2)。

